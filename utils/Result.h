/*
Copyright (C) 1998, 1999, 2000 John Anderson

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Library General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef Result_h
#define Result_h

#include <iostream>
#include <stdexcept>
#include <string>
#include <sstream>
#include <set>

using namespace std;

namespace semilib
{

/**
	\defgroup result Result Handling

	To simplify interacting with API function calls that return an error code
	of some kind. This is a full-on complicated example:
	\code
		try
		{
			typedef
				Result<HANDLE, equal_to, ErrnoMessageMaker<HANDLE, runtime_error> >
				CResult ( -1 )
			;
			CResult result = open ( "somefilename" );
			int next = fgetc ( result );
		}
		catch ( exception & e )
		{
			cerr << e.what() << endl;
		}	
	\endcode
	
	If the called function returns a disallowed value, -1 in this
	case, and the comparator (equal_to in this case) returns true,
	a runtime_error will be thrown. The message given to
	runtime_error is defined by the MessageMaker. You can
	still check the result using the normal if statement handling
	because the Result class has a conversion operator to the type
	you've designated.
	
	The reason there are so many template parameters is that overridding
	classes with overloaded operator =() is a pain. So it seemed easier
	to parameterise the kinds of things a result class could do. Needing
	to repeat (in the example) the HANDLE parameter is also somewhat
	painful. I spose you could typedef it once and reuse it.
*/

/**
	throws an exception when the return value is zero
	
	\ingroup result
	\deprecated use SingleResult instead
*/
template <class ErrorType>
class ErrorOnZero
{
public:
	bool isError( const ErrorType & value ) const
	{
		return value == 0;
	}
};

/**
	throws and exception when the return value is not zero
	\ingroup result
	\deprecated use SingleResult instead
*/
template <class ErrorType>
class ErrorOnNonZero
{
public:
	bool isError( const ErrorType & value ) const
	{
		return value != 0;
	}
};

/**
	Throws an exception when the return value is an
	element of a specified set. Not implemented yet.
	\ingroup result
	\deprecated use SingleResult instead
*/
template <class ErrorType>
class ErrorOnSet
{
public:
	bool isError( const ErrorType & value ) const
	{
	}
};

/**
	This template class is used to create instances of objects
	which can have results assigned to them.
	\ingroup result
	\deprecated use SingleResult instead
*/
template <class Type = unsigned long, class ErrorType = ErrorOnNonZero<Type>, class ExceptionType = runtime_error >
class Result
{
public:

	Result()
	{
	}

	/**
		make an instance of Result that excludes the specified
		parameter.  Which is by default whatever was specified
		as the template parameter
	*/
	Result( Type result )
	{
		operator = ( result );
	}

	/// Copy Constructor
	Result ( const Result & other )
		: _result ( 0 )
	{
		operator = ( other );
	}

	/// standard assignment operator
	const Result & operator = ( const Result & other )
	{
		_result = other._result;
		return *this;
	}

	/**
		assignment operator for using with function calls.
		This checks to see whether the return value from the
		function should throw an exception, and then throws
		the specified exception with a string generated by the
		message virtual method.
	*/
	const Result & operator = ( Type result )
	{
		_result = result;
		checkResult();
		return *this;
	}

	/// for inclusion in STL containers
	bool operator < ( const Result & other ) const
	{
		return _result < other._result;
	}

	/// for inclusion in STL containers
	bool operator == ( const Result & other ) const
	{
		return _result == other._result;
	}

	/// for comparison to the type being checked
	bool operator < ( Type other ) const
	{
		return _result < other;
	}

	/// for comparison to the type being checked
	bool operator == ( Type other ) const
	{
		return _result == other;
	}

	/// conversion operator to the type being checked
	operator Type & ()
	{
		return _result;
	}

	/**
		the message given to the exception thrown in the
		assignment operator. Override this to generate more
		specific error messages.
	*/
	virtual string message ()
	{
		ostringstream os;
		os << "Caught error " << _result;
		return os.str();
	}

	/**
		this is where the actual exception is thrown from.
		Useful if you want special handling of error codes,
		for example fetching a string representation of the
		error code from the system.
	*/
	virtual void throwException()
	{
		throw ExceptionType ( message() );
	}

	/**
		exclude values other than the one specified in the
		constructor.
	*/
	virtual void exclude ( Type value )
	{
		excluded.insert ( value );
	}

	const Type & result() const
	{
		return _result;
	}

	Result & result ( const Type & other )
	{
		_result = other;
		return *this;
	}

protected:
	void checkResult ()
	{
		if ( errorType.isError( _result ) )
		{
			throwException();
		}
	}

private:
	// data members
	Type _result;
	set<Type> excluded;
	ErrorType errorType;
};

/**
	insertion operator
	\deprecated use SingleResult instead
*/
template <class Type, class ErrorType, class ExceptionType>
ostream & operator << ( ostream & os, const Result<Type,ErrorType,ExceptionType> & aResult );

/**
	extraction operator
	\deprecated use SingleResult instead
*/
template <class Type, class ErrorType, class ExceptionType>
istream & operator >> ( istream & is, const Result<Type,ErrorType,ExceptionType> & aResult );

}

#endif
