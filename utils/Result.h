/*
Copyright (C) 1998, 1999, 2000 John Anderson

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Library General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef Result_h
#define Result_h

#include <iostream>
#include <stdexcept>
#include <string>
#include <sstream>
#include <set>

using namespace std;

template <class ErrorType>
class ErrorOnZero
{
public:
	bool isError( const ErrorType & value ) const
	{
		return value == 0;
	}
};

template <class ErrorType>
class ErrorOnNonZero
{
public:
	bool isError( const ErrorType & value ) const
	{
		return value != 0;
	}
};

template <class ErrorType>
class ErrorOnSet
{
public:
	bool isError( const ErrorType & value ) const
	{
	}
};

/**
	to simplify interacting with API calls that return an error code
	of some kind. Use it like this:
	<pre>
		typedef Result<HANDLE, -1, runtime_error> CResult;
		CResult result = open ( "somefilename" );
		HANDLE theHandle = result;
	</pre>
	if the called function returns a disallowed value, -1 in this
	case, a runtime_error will be thrown. The message given to
	runtime_error is defined by the virtual method message. You can
	still check the result using the normal if statement handling
	because the Result class has a conversion operator to the type
	you've designed.
	<p>
	If you want to have more than one value throw an error, use the
	exclude method, or construct the class to use another value. The
	reasoning behind this is that most of the time it's only necessary
	to throw an exception for one value, but occasionally occasionally
	it's necessary to throw an exception for other values as well.
*/
template <class Type = unsigned long, class ErrorType = ErrorOnNonZero<Type>, class ExceptionType = runtime_error >
class Result
{
public:

	Result()
	{
	}

	/**
		make an instance of Result that excludes the specified
		parameter.  Which is by default whatever was specified
		as the template parameter
	*/
	Result( Type result )
	{
		operator = ( result );
	}

	/// Copy Constructor
	Result ( const Result & other )
		: _result ( 0 )
	{
		operator = ( other );
	}

	/// standard assignment operator
	const Result & operator = ( const Result & other )
	{
		_result = other._result;
		return *this;
	}

	/**
		assignment operator for using with function calls.
		This checks to see whether the return value from the
		function should throw an exception, and then throws
		the specified exception with a string generated by the
		message virtual method.
	*/
	const Result & operator = ( Type result )
	{
		_result = result;
		checkResult();
		return *this;
	}

	/// for inclusion in STL containers
	bool operator < ( const Result & other ) const
	{
		return _result < other._result;
	}

	/// for inclusion in STL containers
	bool operator == ( const Result & other ) const
	{
		return _result == other._result;
	}

	/// for comparison to the type being checked
	bool operator < ( Type other ) const
	{
		return _result < other;
	}

	/// for comparison to the type being checked
	bool operator == ( Type other ) const
	{
		return _result == other;
	}

	/// conversion operator to the type being checked
	operator Type & ()
	{
		return _result;
	}

	/**
		the message given to the exception thrown in the
		assignment operator. Override this to generate more
		specific error messages.
	*/
	virtual string message ()
	{
		ostringstream os;
		os << "Caught error " << _result;
		return os.str();
	}

	/**
		this is where the actual exception is thrown from.
		Useful if you want special handling of error codes,
		for example fetching a string representation of the
		error code from the system.
	*/
	virtual void throwException()
	{
		throw ExceptionType ( message() );
	}

	/**
		exclude values other than the one specified in the
		constructor.
	*/
	virtual void exclude ( Type value )
	{
		excluded.insert ( value );
	}

	const Type & result() const
	{
		return _result;
	}

	Result & result ( const Type & other )
	{
		_result = other;
		return *this;
	}

protected:
	void checkResult ()
	{
		if ( errorType.isError( _result ) )
		{
			throwException();
		}
	}

private:
	// data members
	Type _result;
	set<Type> excluded;
	ErrorType errorType;
};

/// insertion operator
template <class Type, class ErrorType, class ExceptionType>
ostream & operator << ( ostream & os, const Result<Type,ErrorType,ExceptionType> & aResult );

/// extraction operator
template <class Type, class ErrorType, class ExceptionType>
istream & operator >> ( istream & is, const Result<Type,ErrorType,ExceptionType> & aResult );

#endif
