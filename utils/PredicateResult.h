/*
Copyright (C) 1998, 1999, 2000 John Anderson

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Library General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef Result_h
#define Result_h

#include <iostream>
#include <stdexcept>
#include <string>
#include <sstream>
#include <set>
#include <functional>

using namespace std;

/**
	To simplify interacting with API function calls that return an error code
	of some kind. Use it like this:
	<pre>
		try
		{
			typedef Result<HANDLE, -1, runtime_error> CResult;
			CResult result = open ( "somefilename" );
			int next = fgetc ( result );
		}
		catch ( exception & e )
		{
			cerr << e.what() << endl;
		}	
	</pre>
	if the called function returns a disallowed value, -1 in this
	case, a runtime_error will be thrown. The message given to
	runtime_error is defined by the virtual method message. You can
	still check the result using the normal if statement handling
	because the Result class has a conversion operator to the type
	you've designed.
	<p>
	If you want to have more than one value throw an error, use the
	exclude method, or construct the class to use another value. The
	reasoning behind this is that most of the time it's only necessary
	to throw an exception for one value, but occasionally occasionally
	it's necessary to throw an exception for other values as well.
	\defgroup result Result Handling
*/

/**
	The basic error check type.
	\ingroup result
*/
class ErrorChecker
{
};

/**
	throws an exception when the return value is zero
	\ingroup result
*/
class ErrorIf
{
public:
	template<class ErrorType>
	bool isError( const ErrorType & value ) const
	{
		return value == error;
	}
};

/**
	throws and exception when the return value is not zero
	\ingroup result
*/
class ErrorIfNot : public ErrorChecker
{
public:
	template <class ErrorType>
	bool operator() ( const ErrorType & value ) const
	{
		return value != error;
	}
};

/**
	Throws an exception when the return value is an
	element of a specified set. Not implemented yet.
	\ingroup result
*/
template <class ErrorType>
class ErrorOnSet
{
public:
	bool operator() ( const ErrorType & value ) const
	{
		// it's an error if it's in the set
		return excluded.find ( value ) != excluded.end();
	}
	set<ErrorType> excluded;
};

/**
	Throws an exception when the return value is an
	element of a specified set. Not implemented yet.
	\ingroup result
*/
template <class ErrorType, ErrorType errorValue = -1>
class ErrorOnValue
{
public:
	bool operator() ( const ErrorType & value ) const
	{
		return value == errorValue;
	}
};

/**
	This template class is used to create instances of objects
	which can have results assigned to them.
	\ingroup result
*/
template <
	class Type = unsigned long
	, class Comparator = equal_to<Type>
	, Type error = 0
	, class ExceptionType = runtime_error
>
class PredicateResult
{
public:

	/**
		make an instance of PredicateResult that excludes the specified
		parameter.  Which is by default whatever was specified
		as the template parameter
	*/
/*
	PredicateResult( Type error )
	: _error ( error )
	{
	}
*/

	/**
		Just construct the result instance for later use.
	*/
	PredicateResult()
	{
	}
	
	/**
		Construct a PredicateResult, and straightaway check
		to see if the value is an error
	*/
	PredicateResult( Type value )
	{
		operator = ( value );
	}

	/// Copy Constructor
	PredicateResult ( const PredicateResult & other )
		: _result ( 0 )
	{
		operator = ( other );
	}

	/// standard assignment operator
	const PredicateResult & operator = ( const PredicateResult & other )
	{
		_result = other._result;
		return *this;
	}

	/**
		assignment operator for using with function calls.
		This checks to see whether the return value from the
		function should throw an exception, and then throws
		the specified exception with a string generated by the
		message virtual method.
	*/
	const PredicateResult & operator = ( Type result )
	{
		_result = result;
		checkPredicateResult();
		return *this;
	}

	/// for inclusion in STL containers
	bool operator < ( const PredicateResult & other ) const
	{
		return _result < other._result;
	}

	/// for inclusion in STL containers
	bool operator == ( const PredicateResult & other ) const
	{
		return _result == other._result;
	}

	/// for comparison to the type being checked
	bool operator < ( Type other ) const
	{
		return _result < other;
	}

	/// for comparison to the type being checked
	bool operator == ( Type other ) const
	{
		return _result == other;
	}

	/// conversion operator to the type being checked
	operator Type & ()
	{
		return _result;
	}

	/**
		the message given to the exception thrown in the
		assignment operator. Override this to generate more
		specific error messages.
	*/
	virtual string message ()
	{
		ostringstream os;
		os << "Caught error " << _result;
		return os.str();
	}

	/**
		this is where the actual exception is thrown from.
		Useful if you want special handling of error codes,
		for example fetching a string representation of the
		error code from the system.
	*/
	virtual void throwException()
	{
		throw ExceptionType ( message() );
	}

	/**
		Exclude the given value from being an error.
		This depends on 
	*/
	virtual void exclude ( Type value )
	{
		//errorType.excluded.insert ( value );
	}

	/**
		Prevent the given value from being excluded. This
	*/
	virtual void unexclude ( Type value )
	{
		//errorType.excluded.erase ( value );
	}

	const Type & result() const
	{
		return _result;
	}

	PredicateResult & result ( const Type & other )
	{
		_result = other;
		return *this;
	}

protected:
	void checkPredicateResult ()
	{
		if ( _comparator( _error, _result ) )
		{
			throwException();
		}
	}

private:
	// data members
	Type _error;
	Type _result;
	Comparator _comparator;

};

/**
	\todo get the insertion and extraction operators working again.
*/
#if 0
/// insertion operator
template <class Type, class ErrorType, class ExceptionType>
ostream & operator << ( ostream & os, const PredicateResult<Type,ErrorType,ExceptionType> & aPredicateResult );

/// extraction operator
template <class Type, class ErrorType, class ExceptionType>
istream & operator >> ( istream & is, const PredicateResult<Type,ErrorType,ExceptionType> & aPredicateResult );

/**
	a stream-type operator to provide several error codes to be rejected
*/
template <class Type, class ErrorType, class ExceptionType>
PredicateResult<Type,ErrorType,ExceptionType> &
operator << (
	PredicateResult<Type,ErrorType,ExceptionType> & aPredicateResult
, const ErrorType & error
)
{
	aPredicateResult.exclude ( error );
}

/**
	a stream-type operator to provide several error codes to be
	removed from the list of rejected codes
*/
template <class Type, class ErrorType, class ExceptionType>
PredicateResult<Type,ErrorType,ExceptionType> &
operator >> (
	PredicateResult<Type,ErrorType,ExceptionType> & aPredicateResult
, const ErrorType & error
)
{
	aPredicateResult.unexclude ( error );
}
#endif

#endif
