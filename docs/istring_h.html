<HTML>
<HEAD>
<TITLE>Source: istring.h</TITLE>
<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>Source: istring.h</h1>
		</TD>
		<TD valign="top" align="right" colspan="1"></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</small></TD></TR>
</TABLE></TD></TR></TABLE>
<pre>
/*
Copyright (C) 1998, John Anderson

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Library General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef istring_h
#define istring_h

#include &lt;string&gt;
#include &lt;locale&gt;
#include &lt;iostream&gt;

using std::char_traits;
using std::basic_string;
using std::string;
using std::locale;
using std::ostream;

#include "Change.h"
#include "utilsdlldef.h"

template&lt;class E=char&gt;
struct UTILS_DLL_API IgnoreCaseTraits : public char_traits&lt;char&gt;
{
	static bool eq(const E &amp; x, const E &amp; y)
	{
		return std::tolower ( x, l ) == std::tolower ( y, l );
	}

	static bool lt(const E &amp; x, const E &amp; y)
	{
		return std::tolower ( x, l ) &lt; std::tolower ( y, l );
	}

	static int compare(const E *x, const E *y, size_t n)
	{
		return strnicmp ( x, y, n );
	}

	static const E *find(const E *x, size_t n, const E&amp; y)
	{
		E temp = std::tolower ( y, l );
		for ( size_t i = 0; i &lt; n; ++i )
		{
			if ( std::tolower ( x[i], l ) == temp )
				return x + i;
		}
		return 0;
	}

private:
	UTILS_DLL_API static locale l;
};

//typedef basic_string&lt;char, IgnoreCaseTraits&lt;char&gt; &gt; istring;
class UTILS_DLL_API istring : public basic_string&lt;char, IgnoreCaseTraits&lt;char&gt; &gt;
{
public:
	istring()
		: basic_string&lt;char, IgnoreCaseTraits&lt;char&gt; &gt; ()
	{
	}

	istring( const char * chstr )
		: basic_string&lt;char, IgnoreCaseTraits&lt;char&gt; &gt; ( chstr )
	{
	}

	istring( const string &amp; astr )
		: basic_string&lt;char, IgnoreCaseTraits&lt;char&gt; &gt; ( astr.c_str() )
	{
		stringCache.recalculate ( true );
	}

	istring &amp; operator = ( const istring &amp; other )
	{
		basic_string&lt;char, IgnoreCaseTraits&lt;char&gt; &gt;::operator = ( other );
		stringCache.recalculate ( true );

		return *this;
	}

	operator const string &amp; () const
	{
		return asString();
	}

	const string &amp; asString() const
	{
		if ( stringCache.recalculate() )
		{
			stringCache = string ( c_str() );
		}
		return stringCache;
	}

private:
	mutable Change&lt;string&gt; stringCache;
};

ostream &amp; UTILS_DLL_API operator&lt;&lt; ( ostream &amp; os, const istring &amp; val );


#endif
</pre>
<HR>
	<table>
	<tr><td><small>Generated by: panic@GROOVIOUS on Wed Mar 22 18:23:58 2000, using kdoc $.</small></td></tr>
	</table>
</BODY>
</HTML>
