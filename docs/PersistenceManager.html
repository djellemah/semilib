<HTML>
<HEAD>
<TITLE>class PersistenceManager</TITLE>
<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>class PersistenceManager</h1>
		</TD>
		<TD valign="top" align="right" colspan="1">
	generic polymorphous (perverse?) persistence manager. <small><A HREF="#longdesc">More...</A></small></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		<TR><TH>Definition</TH><TD><code>#include &lt;<A HREF="PersistenceManager_h.html">PersistenceManager.h</A>&gt;</code></TD></TR>
<TR><TH>Template form</TH><TD>PersistenceManager&lt;template class Persistent&gt; </code></TD></TR>
<TR><TH><A HREF="full-list-PersistenceManager.html">List of all Methods</A></TH></TR>
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</small></TD></TR>
</TABLE></TD></TR></TABLE>
<h4>Public Methods</h4><ul><LI>virtual  void &nbsp;<b>persist</b> ( ostream &amp; os, const Persistent &amp; object )  const
</LI>
<LI>virtual  <A HREF="SmartPointer.html">SmartPointer</A>&lt;Persistent&gt; &nbsp;<b><A HREF="#ref2">restore</A></b> ( istream &amp; is )  const
</LI>
<LI>void &nbsp;<b>writePersistentObjectNames</b> ( ostream &amp; os )  const
</LI>
</ul><h4>Protected Methods</h4><ul><LI>virtual  Persistent * &nbsp;<b><A HREF="#ref4">makeNewObject</A></b> ( const string &amp; line )  const
</LI>
</ul><HR><A NAME="longdesc"><H2>Detailed Description</H2><p>
	generic polymorphous (perverse?) persistence manager. Allows
	objects to be streamed out and read in. Uses the typeid operator
	to write out a name that can be used to construct an instance
	so it can be read in. Relies on the object having a default
	constructor and overloaded operators &gt;&gt; and &lt;&lt;. It's mainly so
	you can read in a bunch of descendant objects from a stream and
	have them come back polymorphously.
&lt;p&gt;
	It also relies on each class that needs to be persistent having the
	following definitions anywhere in the linkage of the program:
</p><pre>

	namespace
	{
		Constructor&amp;lt;Object&amp;gt; instance;
	}

</pre><p>	where Object is the name of the class to be made persistent. The namespace
	is just to ensure that 'instance' doesn't clash with any other names. You 
	can actually call it anything you like: x, i, n, a, b, c, someVeryLongIdentifier.
&lt;p&gt;
	Top persist the class you have to have something like
</p><pre>

	pfn ( ostream &amp; os )
	{
		PersistenceManager&amp;lt;Object&amp;gt; pm;
		Object o;
		pm.persist ( os, o );
	}

</pre><p>	and to restore it, something like
</p><pre>

	rfn( istream &amp; is )
	{
		PersistenceManager&amp;lt;Object&amp;gt; pm;
		SmartPointer&amp;lt;Object&amp;gt; optr = pm.restore ( is );
	}

</pre><p></p><A NAME="restore"></A><A NAME="ref2"></A><table width="100%"><tr bgcolor="#eeeeee"><td><strong> <A HREF="SmartPointer.html">SmartPointer</A>&lt;Persistent&gt; &nbsp;<underline>restore</underline> ( istream &amp; is )
</strong></td></tr></table><p> <small>[const virtual]</small></p><p>
		restores an object from the given stream. You get back a pointer
		because you might be getting a descendant of the object this
		persistence manager can deal with.
	</p><A NAME="makeNewObject"></A><A NAME="ref4"></A><table width="100%"><tr bgcolor="#eeeeee"><td><strong> Persistent * &nbsp;<underline>makeNewObject</underline> ( const string &amp; line )
</strong></td></tr></table><p> <small>[protected const virtual]</small></p><p>
		makes a new object depending on the type information coming
		from the stream.
	</p><HR>
	<table>
	<tr><td><small>Generated by: panic@GROOVIOUS on Wed Mar 22 18:23:58 2000, using kdoc $.</small></td></tr>
	</table>
</BODY>
</HTML>
